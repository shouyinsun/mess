package com.cash.something.netty.im.chat.optimize;
/***
 * 优化
 *
 *通过单例模式改造、编解码器合并、平行指令 handler 合并、
 *慎重选择两种类型的 writeAndFlush() 的方式来压缩优化
 *
 *
 * handler 的处理中,如果有耗时的操作,
 * 需要把这些操作都丢到我们自定义的的业务线程池中处理,
 * 因为 NIO 线程是会有很多 channel 共享的,不能阻塞。
 *
 *
 对于统计耗时的场景,如果在自定义业务线程中调用类似 writeAndFlush() 的异步操作,
 需要通过添加监听器的方式来统计


 连接假死的现象是：在某一端（服务端或者客户端）看来底层的TCP连接已经断开了
 但是应用程序并没有捕获到,因此会认为这条连接仍然是存在的,
 从TCP层面来说,只有收到四次握手数据包或者一个 RST 数据包,连接的状态才表示已断开


 检测闲置,自定义 IdleStateHandler,在 channelIdle() 方法里面自定义连接假死之后的逻辑
 处理假死问题,要实现客户端与服务端定期发送心跳,服务端不用特意发送心跳消息,只需要对客户端的定时心跳包进行回复
 * ***/